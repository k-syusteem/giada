#include <samplerate.h>
#include "const.h"
#include "conf.h"
#include "wave.h"
#include "clock.h"
#include "kernelAudio.h"
#include "sampleChannel.h"
#include "audioProc.h"


namespace giada {
namespace m {
namespace audioProc
{
namespace
{
SRC_STATE* rsmp_state;
SRC_DATA   rsmp_data;


/* -------------------------------------------------------------------------- */


int fillBuffer(SampleChannel* ch, giada::m::AudioBuffer& dest, int start, 
	int offset, bool rewind=true)
{
	rsmp_data.data_in       = ch->wave->getFrame(start);   // source data
	rsmp_data.input_frames  = ch->getEnd() - start;        // how many readable frames
	rsmp_data.data_out      = dest[offset];                // destination (processed data)
	rsmp_data.output_frames = dest.countFrames() - offset; // how many frames to process
	rsmp_data.end_of_input  = false;

	src_process(rsmp_state, &rsmp_data);

	int position = start + rsmp_data.input_frames_used; // position goes forward of frames_used (i.e. read from wave)

	if (rewind) {
		int gen = rsmp_data.output_frames_gen;            // frames generated by this call
		if (gen == dest.countFrames() - offset)
			ch->frameRewind = -1;
		else
			ch->frameRewind = gen + offset;
	}
	return position;
}


/* -------------------------------------------------------------------------- */


void quantize(SampleChannel* ch, int index, int localFrame, int globalFrame)
{
	/* skip if LOOP_ANY or not in quantizer-wait mode */

	if ((ch->mode & LOOP_ANY) || !ch->qWait)
		return;

	/* no fadeout if the sample starts for the first time (from a
	 * STATUS_OFF), it would be meaningless. */

	if (ch->status == STATUS_OFF) {
		ch->status  = STATUS_PLAY;
		ch->sendMidiLplay();/* TODO ********** */
		ch->qWait   = false;
		ch->tracker = fillBuffer(ch, ch->vChan, ch->tracker, localFrame); /// FIXME: ???
	}
	else
		//setXFade(localFrame * 2);
		ch->reset(localFrame);/* TODO ********** */

	/* this is the moment in which we record the keypress, if the
	 * quantizer is on. SINGLE_PRESS needs overdub */

	if (recorder::canRec(ch, clock::isRunning(), mixer::recording)) {/* TODO no globals */
		if (ch->mode == SINGLE_PRESS) {
			recorder::startOverdub(index, G_ACTION_KEYS, globalFrame, 
				kernelAudio::getRealBufSize()); /* TODO no globals */
			ch->readActions = false;   // don't read actions while overdubbing
		}
		else
			recorder::rec(index, G_ACTION_KEYPRESS, globalFrame);
		ch->hasActions = true;
	}	
}


/* -------------------------------------------------------------------------- */


void onBar(SampleChannel* ch, int localFrame)
{
	if (ch->mode == LOOP_REPEAT) {
		if (ch->status == STATUS_PLAY)
			ch->reset(localFrame);/* TODO ********** */
	}
	else
	if (ch->mode == LOOP_ONCE_BAR) {
		if (ch->status == STATUS_WAIT) {
			ch->status  = STATUS_PLAY;
			ch->tracker = fillBuffer(ch, ch->vChan, ch->tracker, localFrame);
			ch->sendMidiLplay();/* TODO ********** */
		}
	}	
}


/* -------------------------------------------------------------------------- */


void onFirstBeat(SampleChannel* ch, int localFrame)
{
	if (ch->wave == nullptr)
		return;

	if (ch->mode & LOOP_ANY) {

		/* FIXME - Should do a crossfade if the sample is playing. Regular ch->reset
		instead if it's muted, otherwise a click occurs. */

		if (ch->status == STATUS_PLAY)
			ch->reset(localFrame);/* TODO ********** */
		else
		if (ch->status == STATUS_ENDING)
			ch->hardStop(localFrame);/* TODO ********** */
	}

	if (ch->status == STATUS_WAIT) { /// FIXME - should be inside previous if!
		ch->status  = STATUS_PLAY;
		ch->sendMidiLplay();/* TODO ********** */
		ch->tracker = fillBuffer(ch, ch->vChan, ch->tracker, localFrame);
	}

	if (ch->recStatus == REC_ENDING) {
		ch->recStatus = REC_STOPPED;
		ch->setReadActions(false, conf::recsStopOnChanHalt);  // rec stop  /* TODO ********** */
	}
	else
	if (ch->recStatus == REC_WAITING) {
		ch->recStatus = REC_READING;
		ch->setReadActions(true, conf::recsStopOnChanHalt);   // rec start  /* TODO ********** */
	}	
}


/* -------------------------------------------------------------------------- */


void parseAction(SampleChannel* ch, recorder::action a, int localFrame, 
	int globalFrame)
{
	if (ch->readActions == false)
		return;

	switch (a.type) {
		case G_ACTION_KEYPRESS:
			if (ch->mode & SINGLE_ANY)
				ch->start(localFrame, false, clock::getQuantize(), clock::isRunning(), false, false);  /* TODO ********** */
			break;
		case G_ACTION_KEYREL:
			if (ch->mode & SINGLE_ANY)
				ch->stop();  /* TODO ********** */
			break;
		case G_ACTION_KILL:
			if (ch->mode & SINGLE_ANY)
				ch->kill(localFrame);  /* TODO ********** */
			break;
		case G_ACTION_MUTEON:
			ch->setMute(true);   // internal mute  /* TODO ********** */
			break;
		case G_ACTION_MUTEOFF:
			ch->unsetMute(true); // internal mute  /* TODO ********** */
			break;
		case G_ACTION_VOLUME:
			ch->calcVolumeEnv(globalFrame);  /* TODO ********** */
			break;
	}
}


/* -------------------------------------------------------------------------- */


void sum(SampleChannel* ch, int frame)
{
	if (ch->wave == nullptr || ch->status & ~(STATUS_PLAY | STATUS_ENDING))
		return;

	if (frame != ch->frameRewind) {

		/* volume envelope, only if seq is running */

		if (clock::isRunning()) {
			ch->volume_i += ch->volume_d;
			if (ch->volume_i < 0.0f)
				ch->volume_i = 0.0f;
			else
			if (ch->volume_i > 1.0f)
				ch->volume_i = 1.0f;
		}

		/* fadein or fadeout processes. If mute, delete any signal. */

		/** TODO - big issue: fade[in/out]Vol * internal_volume might be a
		 * bad choice: it causes glitches when muting on and off during a
		 * volume envelope. */

		if (ch->mute || ch->mute_i) {
			for (int i=0; i<ch->vChan.countChannels(); i++)
				ch->vChan[frame][i] = 0.0f;
		}
		else
		if (ch->fadeinOn) {
			if (ch->fadeinVol < 1.0f) {
				for (int i=0; i<ch->vChan.countChannels(); i++)
					ch->vChan[frame][i] *= ch->fadeinVol * ch->volume_i;
				ch->fadeinVol += 0.01f;
			}
			else {
				ch->fadeinOn  = false;
				ch->fadeinVol = 0.0f;
			}
		}
		else
		if (ch->fadeoutOn) {
			if (ch->fadeoutVol > 0.0f) { // fadeout ongoing
				if (ch->fadeoutType == SampleChannel::XFADE) {
					for (int i=0; i<ch->vChan.countChannels(); i++)
						ch->vChan[frame][i] = ch->pChan[frame][i] * ch->fadeoutVol * ch->volume_i;
				}
				else {
					for (int i=0; i<ch->vChan.countChannels(); i++)
						ch->vChan[frame][i] *= ch->fadeoutVol * ch->volume_i;
				}
				ch->fadeoutVol -= ch->fadeoutStep;
			}
			else {  // fadeout end
				ch->fadeoutOn  = false;
				ch->fadeoutVol = 1.0f;

				/* QWait ends with the end of the xfade */

				if (ch->fadeoutType == SampleChannel::XFADE) {
					ch->qWait = false;
				}
				else {
					if (ch->fadeoutEnd == SampleChannel::DO_MUTE)
						ch->mute = true;
					else
					if (ch->fadeoutEnd == SampleChannel::DO_MUTE_I)
						ch->mute_i = true;
					else             // DO_STOP
						ch->hardStop(frame);
				}
			}
		}
		else {
			for (int i=0; i<ch->vChan.countChannels(); i++)
				ch->vChan[frame][i] *= ch->volume_i;
		}
	}
	else { // at this point the sample has reached the end */

		if (ch->mode & (SINGLE_BASIC | SINGLE_PRESS | SINGLE_RETRIG) ||
			 (ch->mode == SINGLE_ENDLESS && ch->status == STATUS_ENDING)   ||
			 (ch->mode & LOOP_ANY && !clock::isRunning()))     // stop loops when the seq is off
		{
			ch->status = STATUS_OFF;
			ch->sendMidiLplay();
		}

		/* LOOP_ONCE or LOOP_ONCE_BAR: if ending (i.e. the user requested their
		 * termination), kill 'em. Let them wait otherwise. But don't put back in
		 * wait mode those already stopped by the conditionals above. */

		if (ch->mode & (LOOP_ONCE | LOOP_ONCE_BAR)) {
			if (ch->status == STATUS_ENDING)
				ch->status = STATUS_OFF;
			else
			if (ch->status != STATUS_OFF)
				ch->status = STATUS_WAIT;
		}

		/* Check for end of samples. SINGLE_ENDLESS runs forever unless it's in 
		ENDING mode. */

		ch->reset(frame);
	}
}
}; // {anonymous}


/* -------------------------------------------------------------------------- */
/* -------------------------------------------------------------------------- */
/* -------------------------------------------------------------------------- */


void prepare(SampleChannel* ch, mixer::FrameEvents ev)
{

}
}}};